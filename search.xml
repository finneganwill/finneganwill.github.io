<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/03/12/HelloWorld/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<img src="/2022/03/12/HelloWorld/hello-world.png" class="" title="hello-world"> 

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>HelloWorld</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo&amp;Github搭建个人静态博客（Win）</title>
    <url>/2022/03/13/Hexo&amp;Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>Hexo是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<h1 id="1-什么是静态博客？"><a href="#1-什么是静态博客？" class="headerlink" title="1. 什么是静态博客？"></a>1. 什么是静态博客？</h1><p>所谓静态博客就是通过生成工具（例如Hexo；Halo等），直接将作者所书写的博文编译成最终的 html；css；js 等静态文件。作者/博主只需将生成的文件部署在服务器 面即可被在互联网中访问。 其他用户通过浏览器访问服务器就会浏览到博客啦。</p>
<h1 id="2-安装教程"><a href="#2-安装教程" class="headerlink" title="2. 安装教程"></a>2. 安装教程</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p>下载：<a href="https://nodejs.org/">Node.js 官网</a> | <a href="http://nodejs.cn/">Node.js 中文网</a> </p>
<p>安装：<a href="">我的安装教程</a> | <a href="http://nodejs.cn/learn">官方文档</a>  </p>
<h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p>下载：<a href="https://git-scm.com/">Git 官网</a> </p>
<p>安装：<a href="">我的安装教程</a> </p>
<h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><p>首先你需要有一个账号，关于Github账号的创建这里就不再赘述了。</p>
<h3 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h3><ol>
<li><p>创建仓库时需要注意，仓库名的格式必须是：<code>用户名.github.io</code>。其他选项可根据需要自行设置。</p>
<blockquote>
<img src="/2022/03/13/Hexo&Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/image-20220316104424889.png" class="" title="image-20220316104424889">
</blockquote>
</li>
<li><p>创建好仓库后，就可以使用地址访问了</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">https://用户名.github.io</span><br></pre></td></tr></table></figure>

<p>或者在你的仓库中进入Settings，在网页最下面Github Pages，点击进入就可以看到你的站点信息了。</p>
<blockquote>
<img src="/2022/03/13/Hexo&Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/image-20220316105310854.png" class="" title="image-20220316105310854"> 
</blockquote>
<blockquote>
<img src="/2022/03/13/Hexo&Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/image-20220316105332704.png" class="" title="image-20220316105332704">
</blockquote>
<blockquote>
<img src="/2022/03/13/Hexo&Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/image-20220316105439070.png" class="" title="image-20220316105439070">  </blockquote>
</li>
</ol>
<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p>本地环境与远程仓库准备好后就可以来安装和使用Hexo了，无论是安装还是后面的写作与部署可以参考<a href="https://hexo.io/zh-cn/docs/">官方文档</a> </p>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><ol>
<li><p>打开命令行窗口，在命令行中使用npm安装Hexo：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli </span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ol>
<li><p>选择一个目录用来保存网站资源，比如这里在桌面准备了一个 Blog 目录：</p>
<blockquote>
<img src="/2022/03/13/Hexo&Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/image-20220314211133967.png" class="" title="image-20220314211133967"> </blockquote>
</li>
<li><p>使用Git Bash进入该目录（在该目录下<code>右键 -&gt; Git Bash Here</code> 或者 <code>打开Git Bash Here使用命令进入指定目录</code> ）：</p>
<blockquote>
<img src="/2022/03/13/Hexo&Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/image-20220314211306592.png" class="" title="image-20220314211306592"> </blockquote>
</li>
<li><p>Git Bash中执行初始化命令可以生成站点所需要的的文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化站点文件</span></span><br><span class="line">hexo init</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">npm安装</span></span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ol>
<li><p>生成网页文件，Git Bash输入命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure></li>
<li><p>启动本地站点服务，Git Bash输入命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure></li>
<li><p>预览，浏览器地址栏输入：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">http://localhost:4000</span><br></pre></td></tr></table></figure>

<blockquote>
<img src="/2022/03/13/Hexo&Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/image-20220316102402450.png" class="" title="image-20220316102402450"> </blockquote>
</li>
</ol>
<h1 id="3-简单使用"><a href="#3-简单使用" class="headerlink" title="3. 简单使用"></a>3. 简单使用</h1><p>搭建好Hexo就可以编写自己的博客了，Hexo默认创建的是markdown格式的文件；</p>
<h2 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h2><ol>
<li><p>在Blog目录下启动Git Bash，并执行下面的命令会新建 <code>.md</code> 文件，默认（post布局）会存储在<code>source/_posts</code> 目录下，然后可以使用编写Markdown的软件编写你的文档了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建文档</span></span><br><span class="line">hexo new [layout] &lt;title&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># layout选项</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">post - 默认</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">page</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">draft</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写好文档后就可以生成网页文件以及预览了（见 <a href="#%E6%B5%8B%E8%AF%95">测试</a> ）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成网页文件</span></span><br><span class="line">hexo g</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动本地服务预览</span></span><br><span class="line">hexo s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">浏览器输入查看效果</span></span><br><span class="line">localhost:4000</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>生成网页文件后，除了本地预览，还可以部署到你的站点了</p>
<ol>
<li><p>安装git推送插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li>
<li><p>修改全局配置文件<code>_config.yml</code> </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在配置文件中找到deploy参数，并将参数值设为如下：</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:用户名/用户名.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>

<p>其中<code>repository</code> 值可以到Github博客仓库中复制：</p>
<blockquote>
<img src="/2022/03/13/Hexo&Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/image-20220316210812099.png" class="" title="image-20220316210812099"> </blockquote>
</li>
<li><p>推送文档</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>更换主题可以到 <a href="https://hexo.io/themes/">Hexo主题站</a> 浏览下载，关于主题的安装可参考主题文档（一般Github主题项目中都会有介绍），有时间的话我会再写一篇关于主题更换的博客。</p>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p><a href="https://hexo.io/zh-cn/docs/">Hexo官方文档 - 中文</a> </p>
<h2 id="Hexo命令"><a href="#Hexo命令" class="headerlink" title="Hexo命令"></a>Hexo命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装hexo</span></span><br><span class="line">npm install -g hexo-cli</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化</span></span><br><span class="line">hexo init </span><br><span class="line">npm install</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装推送插件</span></span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 新建文档 &amp; 草稿publish &amp; 生成网页文件 &amp; 本地预览 &amp; 推送文章</span></span></span><br><span class="line">hexo new &lt;title&gt; </span><br><span class="line">hexo publish &lt;title&gt;</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>



<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol>
<li>Github服务器位于国外，在国内访问速度受限，博客部署 <code>hexo d</code> 的时候经常会失败，这种情况就多部署几次直至成功就可以了。</li>
<li>如果嫌弃访问速度过慢可以用Gitee替换Github（搭建步骤基本一致）或者自行加速。</li>
<li>部署后站点内容可能不会立即刷新，稍等一会重新进入就可以了。</li>
</ol>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github Pages</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 对象拷贝.md</title>
    <url>/2022/04/26/Java%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h1 id="1-Java中创建对象的5种方式"><a href="#1-Java中创建对象的5种方式" class="headerlink" title="1. Java中创建对象的5种方式"></a>1. Java中创建对象的5种方式</h1><h2 id="1-1-new"><a href="#1-1-new" class="headerlink" title="1.1 new"></a>1.1 new</h2><p><code>new</code> 关键字创建对象是最常规的一种方法，可以通过调用有参或无参的构造方法实现对象的创建，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>

<h2 id="1-2-clazz-newInstance"><a href="#1-2-clazz-newInstance" class="headerlink" title="1.2 clazz.newInstance()"></a>1.2 clazz.newInstance()</h2><p>通过 <code>Class</code> 类的API实现创建对象，是一种反射方式。这种方式调用的是 public 无参构造，因此<strong>类必须具有公有的无参构造</strong>，否则会报错。</p>
<blockquote>
<p>这种方式在 Java 9 之后已经不推荐使用了：</p>
<img src="/2022/04/26/Java%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D/%E5%BC%83%E7%94%A8.png" class="" title="image-20220426113812098">  
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> Student.class.newInstance(); <span class="comment">// 方式一</span></span><br><span class="line"></span><br><span class="line"><span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> (Student) Class.forName(<span class="string">&quot;my.finn.Student&quot;</span>).newInstance(); <span class="comment">// 方式二</span></span><br></pre></td></tr></table></figure>

<h2 id="1-3-constructor-newInstance"><a href="#1-3-constructor-newInstance" class="headerlink" title="1.3 constructor.newInstance()"></a>1.3 constructor.newInstance()</h2><p> java.lang.reflect.Constructor 类中也有一个 newInstance() 方法可以创建对象，和上一个方法一样，也是一种反射方式。通过这个方法<strong>可以调用无/有参和公/私有的构造方法</strong>。</p>
<blockquote>
<p>实际上 clazz.newInstance() 内部仍然是调用的 constructor.newInstance()</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constructor&lt;?&gt;[] declaredConstructors = Student.class.getDeclaredConstructors(); <span class="comment">// 获取所有构造方法</span></span><br><span class="line"></span><br><span class="line">Constructor&lt;?&gt;[] publicConstructors = Student.class.getConstructors(); <span class="comment">// 获取public的构造方法</span></span><br><span class="line"></span><br><span class="line">Constructor&lt;?&gt; constructor = declaredConstructors[<span class="number">0</span>]; <span class="comment">// 从数组中获取要使用的构造方法</span></span><br><span class="line"></span><br><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> (Student)constructor.newInstance(); <span class="comment">// 创建对象，newInstance中需要填入相应构造方法的参数</span></span><br></pre></td></tr></table></figure>

<h2 id="1-4-Clone"><a href="#1-4-Clone" class="headerlink" title="1.4 Clone"></a>1.4 Clone</h2><p>Object类中提供了一个 native 的 clone() 方法，A.clone() 会创建一个内容和对象 A 相同的对象，使用该方式<strong>不会调用构造方法</strong>。</p>
<blockquote>
<p>protected native Object clone() throws CloneNotSupportedException;</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> s1.clone();</span><br></pre></td></tr></table></figure>

<h2 id="1-5-反序列化"><a href="#1-5-反序列化" class="headerlink" title="1.5 反序列化"></a>1.5 反序列化</h2><p>反序列化是把磁盘文件中的对象数据或者把网络节点上的对象数据，恢复成Java对象模型的过程，反序列化<strong>不会调用任何构造函数</strong>。</p>
<h1 id="2-对象拷贝"><a href="#2-对象拷贝" class="headerlink" title="2. 对象拷贝"></a>2. 对象拷贝</h1><h2 id="2-1-引用拷贝"><a href="#2-1-引用拷贝" class="headerlink" title="2.1 引用拷贝"></a>2.1 引用拷贝</h2><p><strong>引用拷贝：创建一个引用，该引用与原引用都指向同一个对象。</strong> </p>
<img src="/2022/04/26/Java%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D/%E5%BC%95%E7%94%A8%E6%8B%B7%E8%B4%9D.png" class="" title="引用拷贝"> 

<h2 id="2-2-浅拷贝"><a href="#2-2-浅拷贝" class="headerlink" title="2.2 浅拷贝"></a>2.2 浅拷贝</h2><p><strong>浅拷贝：创建一个引用，并对对象进行拷贝，将创建的引用指向拷贝对象，拷贝时：</strong></p>
<ul>
<li><strong>基本数据类型的字段进行值复制</strong> </li>
<li><strong>引用类型的字段复制一份引用并指向原引用所指向的对象</strong> </li>
</ul>
<img src="/2022/04/26/Java%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D/%E6%B5%85%E6%8B%B7%E8%B4%9D.png" class="" title="浅拷贝"> 

<h2 id="2-3-深拷贝"><a href="#2-3-深拷贝" class="headerlink" title="2.3 深拷贝"></a>2.3 深拷贝</h2><p><strong>深拷贝：创建一个引用，并对对象进行拷贝，将创建的引用指向拷贝对象，拷贝时：</strong></p>
<ul>
<li><strong>基本数据类型的字段进行值复制</strong> </li>
<li><strong>引用类型的字段将引用和引用的对象都复制一份，并将拷贝引用指向拷贝对象</strong> </li>
</ul>
<blockquote>
<p>实现深拷贝的方法：</p>
<ul>
<li>反序列化</li>
<li>重写clone()方法时把属性拷贝</li>
</ul>
</blockquote>
<img src="/2022/04/26/Java%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D/%E6%B7%B1%E6%8B%B7%E8%B4%9D.png" class="" title="深拷贝"> 

<h1 id="3-示例"><a href="#3-示例" class="headerlink" title="3 示例"></a>3 示例</h1><h2 id="Person-class"><a href="#Person-class" class="headerlink" title="Person.class"></a>Person.class</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age, Address address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//省略setter/getter</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123; <span class="comment">//实现Cloneable接口中的clone()方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone(); <span class="comment">//默认浅拷贝</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">(<span class="type">boolean</span> b)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123; <span class="comment">// 深拷贝(为了方便测试这里就直接重载)</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) <span class="built_in">this</span>.clone();</span><br><span class="line">        p.address = (Address) <span class="built_in">this</span>.address.clone();</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Address-class"><a href="#Address-class" class="headerlink" title="Address.class"></a>Address.class</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Address</span><span class="params">(String city)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.city = city;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略setter/getter</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Main-class"><a href="#Main-class" class="headerlink" title="Main.class"></a>Main.class</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Address</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;China&quot;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Finn&quot;</span>, <span class="number">18</span>, address);</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">clonedPerson</span> <span class="operator">=</span> person; <span class="comment">// 引用拷贝</span></span><br><span class="line">        System.out.println(<span class="string">&quot;**************** 引用拷贝 ****************&quot;</span>);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">        System.out.println(clonedPerson);</span><br><span class="line">        System.out.println(person.getAddress());</span><br><span class="line">        System.out.println(clonedPerson.getAddress());</span><br><span class="line"></span><br><span class="line">        clonedPerson = (Person) person.clone(); <span class="comment">// 浅拷贝</span></span><br><span class="line">        System.out.println(<span class="string">&quot;**************** 浅拷贝 ****************&quot;</span>);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">        System.out.println(clonedPerson);</span><br><span class="line">        System.out.println(person.getAddress());</span><br><span class="line">        System.out.println(clonedPerson.getAddress());</span><br><span class="line"></span><br><span class="line">        clonedPerson = (Person) person.clone(<span class="literal">true</span>); <span class="comment">// 深拷贝</span></span><br><span class="line">        System.out.println(<span class="string">&quot;**************** 深拷贝 ****************&quot;</span>);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">        System.out.println(clonedPerson);</span><br><span class="line">        System.out.println(person.getAddress());</span><br><span class="line">        System.out.println(clonedPerson.getAddress());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Print"><a href="#Print" class="headerlink" title="Print"></a>Print</h2><img src="/2022/04/26/Java%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D/%E6%8B%B7%E8%B4%9D%E6%89%93%E5%8D%B0%E7%A4%BA%E4%BE%8B.png" class="" title="拷贝打印示例"> 

<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h1><ol>
<li><p>java中创建对象的几种方式</p>
<blockquote>
<ul>
<li>new</li>
<li>clazz.newInstance(); // java 9 开始弃用</li>
<li>constructor.newInstance();</li>
<li>obj.clone(); // 默认浅拷贝</li>
<li>deseriallization </li>
</ul>
</blockquote>
</li>
<li><p>拷贝</p>
<blockquote>
<ul>
<li>引用拷贝：创建一个引用指向原对象</li>
<li>浅拷贝：基本类型进行值复制；引用类型只复制引用，不复制引用的对象；clone()方法默认采用浅拷贝实现</li>
<li>深拷贝：基本类型进行值复制；引用类型既复制引用，也复制引用的对象</li>
</ul>
</blockquote>
</li>
<li><p>实现深拷贝</p>
<blockquote>
<ul>
<li>序列化与反序列化</li>
<li>重写clone()方法时把属性也拷贝</li>
</ul>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>OOP</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>深浅拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>Java hashCode()与equals()</title>
    <url>/2022/04/30/hashCode%E6%96%B9%E6%B3%95%E4%B8%8Eequals%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>Java中有一个顶级父类 <code>Object</code> ，Java 允许把任何类型的对象赋给 Object 类型的变量。当一个类被定义后，如果没有指定继承的父类，那么默认父类就是 Object 类。今天就来聊聊Object类中两个方法：<code>equals()</code> 和 <code>hashCode()</code> 。</p>
<h1 id="1-equals"><a href="#1-equals" class="headerlink" title="1. equals()"></a>1. equals()</h1><p><code>equals()</code> 用来比较两个对象之间的是否相等。它的源码（JDK11）如下：</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Indicates whether some other object is &quot;equal to&quot; this one.</span></span><br><span class="line"><span class="comment">The equals method implements an equivalence relation on non-null object references:</span></span><br><span class="line"><span class="comment">It is reflexive: for any non-null reference value x, x.equals(x) should return true.</span></span><br><span class="line"><span class="comment">It is symmetric: for any non-null reference values x and y, x.equals(y) should return true if and only if y.equals(x) returns true.</span></span><br><span class="line"><span class="comment">It is transitive: for any non-null reference values x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true.</span></span><br><span class="line"><span class="comment">It is consistent: for any non-null reference values x and y, multiple invocations of x.equals(y) consistently return true or consistently return false, provided no information used in equals comparisons on the objects is modified.</span></span><br><span class="line"><span class="comment">For any non-null reference value x, x.equals(null) should return false.</span></span><br><span class="line"><span class="comment">The equals method for class Object implements the most discriminating possible equivalence relation on objects; that is, for any non-null reference values x and y, this method returns true if and only if x and y refer to the same object (x == y has the value true).</span></span><br><span class="line"><span class="comment">Note that it is generally necessary to override the hashCode method whenever this method is overridden, so as to maintain the general contract for the hashCode method, which states that equal objects must have equal hash codes.</span></span><br><span class="line"><span class="comment">Params:</span></span><br><span class="line"><span class="comment">obj – the reference object with which to compare.</span></span><br><span class="line"><span class="comment">Returns:</span></span><br><span class="line"><span class="comment">true if this object is the same as the obj argument; false otherwise.</span></span><br><span class="line"><span class="comment">See Also: hashCode(), java.util.HashMap</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;<span class="keyword">return</span> (<span class="built_in">this</span> == obj);&#125;</span><br></pre></td></tr></table></figure>

<p>【注释文档翻译】</p>
<p>表示其他对象是否 “等于”这个对象。equals方法实现了对非空对象引用的等价关系。</p>
<p>它是自反的：对于任何非空的引用值 x，x.equals(x) 应该返回 true。<br>它是对称的：对于任何非空的引用值 x 和 y，x.equals(y) 应该返回 true，当且仅当 y.equals(x) 返回 true。<br>它是传递的：对于任何非空参考值 x、y 和 z，如果 x.equals(y) 返回 true，y.equals(z) 返回 true ，那么 x.equals(z) 应该返回 true。<br>它是一致的：对于任何非空的参考值 x 和 y，如果没有修改对象上的等价比较信息，多次调用 x.equals(y) 一致地返回 true 或一致地返回 false。</p>
<p>对于任何非空的引用值 x，x.equals(null) 应该返回 false。</p>
<p>Object类的 equals 方法在对象上实现了最有鉴别力的等价关系；也就是说，对于任何非空的引用值 x 和 y ，当且仅当 x 和 y 指向同一个对象时，该方法返回 true（x == y的值为true）。</p>
<p><strong>请注意，一般来说，只要重写这个方法，就必须重写hashCode方法，这样才能保持hashCode方法的一般契约，即相等的对象必须有相等的哈希代码。</strong> </p>
<p>参数：obj - 与之比较的参考对象。</p>
<p>返回：true 如果这个对象与obj 参数相同；否则为false。</p>
<p>参见：hashCode(), java.util.HashMap</p>
</blockquote>
<p>可以看到，注释文档已经把 equals() 介绍的很详细了，主要总结为一下几点：</p>
<ol>
<li><strong>用来判断对象的等价关系</strong></li>
<li><strong>具有自反性、对称性、传递性、一致性</strong></li>
<li><strong>调用该方法的对象不能为空，否则会报空指针异常（NullPointerException, NPE）</strong></li>
<li><strong>对于任何非空的引用值 x 和 y ，当且仅当 x 和 y 指向同一个对象时，该方法返回 true</strong></li>
<li><strong>重写equals()时必须重写hashCode()</strong> </li>
</ol>
<hr>
<p>对于前两点就不在多解释了，值得注意的是第3点，我们在IDEA（v2021.2）上使用空引用调用equals()时编译器并不会直接标红报错，而是会标黄。这种情况下不影响编译器编译，但在程序运行时会报错，在编写程序时要注意。</p>
<p>比如在进行String对象与字符串比较时通常把已确定的字符串放在前，把String对象作equals()的参数传入，即：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str= <span class="string">&quot;Hello World&quot;</span></span><br><span class="line"><span class="string">&quot;Hello World&quot;</span>.equals(str);</span><br></pre></td></tr></table></figure>

<hr>
<p>关于第4点，在源码中可以看到Object类中的equals()判断使用的是 <code>==</code> 。关于 == 运算符：</p>
<ul>
<li> 判断基本数据类型时，是判断的值是否相同</li>
<li>判断引用数据类型时，是比较是否指向同一对象，亦即地址值是否相同</li>
</ul>
<p>但是在业务中我们通常需要判断两个对象是否具有相同的内容，此时使用 == 就不能满足要求了，因此才需要通过重写euqals()来实现这样的逻辑，这也是 <code>==</code> 与 <code>equals()</code> 区别的根本所在。比如String类中的重写</p>
<img src="/2022/04/30/hashCode%E6%96%B9%E6%B3%95%E4%B8%8Eequals%E6%96%B9%E6%B3%95/StringEquals.png" class="" title="StringEquals"> 

<hr>
<p>关于第5点，重写equals()时必须重写hashCode()，文档中说明了是为了“保持hashCode方法的一般契约，即相等的对象必须有相等的哈希代码”。更多原因可以继续参考 <em>3. 为什么要同时重写equals()和hashCode()？</em> 详细理解。</p>
<h1 id="2-hashCode"><a href="#2-hashCode" class="headerlink" title="2. hashCode()"></a>2. hashCode()</h1><p><code>hashCode()</code> 用来返回该对象的哈希代码值（一个整数）。它的源码（JDK11）如下：</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Returns a hash code value for the object. This method is supported for the benefit of hash tables such as those provided by java.util.HashMap.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The general contract of hashCode is:</span></span><br><span class="line"><span class="comment">- Whenever it is invoked on the same object more than once during an execution of a Java application, the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application.</span></span><br><span class="line"><span class="comment">- If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result.</span></span><br><span class="line"><span class="comment">- It is not required that if two objects are unequal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce distinct integer results. However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hash tables.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">As much as is reasonably practical, the hashCode method defined by class Object does return distinct integers for distinct objects. (The hashCode may or may not be implemented as some function of an object&#x27;s memory address at some point in time.)</span></span><br><span class="line"><span class="comment">Returns:</span></span><br><span class="line"><span class="comment">a hash code value for this object.</span></span><br><span class="line"><span class="comment">See Also:</span></span><br><span class="line"><span class="comment">equals(Object), System.identityHashCode</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>【注释文档翻译】</p>
<p>返回该对象的哈希代码值。支持这个方法是为了让哈希表受益，比如java.util.HashMap提供的哈希表。</p>
<p>hashCode的一般契约是：</p>
<ul>
<li>在一个Java应用程序的执行过程中，无论何时对同一个对象调用多次，hashCode方法都必须一致地返回相同的整数，前提是在对象的等价比较中使用的信息没有被修改。这个整数不需要在一个应用程序的执行过程中与同一应用程序的另一个执行过程保持一致。</li>
<li>如果两个对象根据equals(Object)方法是相等的，那么在这两个对象上调用hashCode方法必须产生相同的整数结果。</li>
<li>如果根据equals(Object)方法，两个对象不相等，那么在这两个对象上调用hashCode方法必须产生不同的整数结果，这一点并不要求。然而，程序员应该知道，为不相等的对象产生不同的整数结果可能会提高哈希表的性能。</li>
</ul>
<p>在合理可行的情况下，由Object类定义的hashCode方法确实为不同的对象返回不同的整数。(hashCode可能是也可能不是在某个时间点作为对象的内存地址的某个函数来实现)。</p>
<p>Return：该对象的哈希代码值<br>也请参见：equals(Object), System.identityHashCode</p>
</blockquote>
<p>从源码可以看到，Object类中的 hashCode() 是一个 <code>native</code> 方法。文档中也说明了前文提到的“hashCode的一般契约”，可以总结为一下几点：</p>
<ol>
<li>在同一次的应用执行过程中，同一个对象多次调用 hashCode() 返回的结果不变</li>
<li>equals() 返回 true 时，两个对象的 hashCode() 返回的结果必须相同（为同一个整数）</li>
<li>equals() 返回 false 时，两个对象的 hashCode() 返回的结果可以相同，但为不相等的对象产生不同的整数结果可能会提高哈希表的性能</li>
<li>在合理可行的情况下，由Object类定义的 hashCode() 确实为不同的对象返回不同的整数</li>
</ol>
<p>第4点就是为什么重写 equals() 时也要重写hashCode()的根本所在，可以参考这里 <em>3.为什么要同时重写equals()和hashCode()？</em> 详细理解。</p>
<h1 id="3-equals-与-的区别"><a href="#3-equals-与-的区别" class="headerlink" title="3. equals() 与 == 的区别"></a>3. equals() 与 == 的区别</h1><p>首先需要明确的是 <code>==</code> 是关系运算符，而 <code>equals()</code> 是方法，从这一点上就可以总结出二者的区别。</p>
<p>== 作为关系运算符在Java语法中具有通用性，换句话说既可以用来比较基本数据类型，也可以比较引用类型：</p>
<ul>
<li> 判断基本类型时，是判断的值是否相同</li>
<li>判断引用类型时，是比较是否指向同一对象，亦即地址值是否相同</li>
</ul>
<p>而 euqals() 归根是一个方法，因此对于基本类型来说是不存在调用方法这种行为的，它只能被一个对象实例调用。</p>
<p>Object类中的 equals() 逻辑是用 == 实现的，此时比较的是两个引用所指向的地址：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;<span class="keyword">return</span> (<span class="built_in">this</span> == obj);&#125;</span><br></pre></td></tr></table></figure>

<p>如果要实现判断两个对象内容是否相同时，需要对 equals() 重写，如String类中通过重写实现了两个字符串内容的比较。</p>
<h1 id="4-为什么要同时重写-equals-和-hashCode-？"><a href="#4-为什么要同时重写-equals-和-hashCode-？" class="headerlink" title="4. 为什么要同时重写 equals() 和 hashCode() ？"></a>4. 为什么要同时重写 equals() 和 hashCode() ？</h1><p><strong>符合Java对于 hashCode 的一般契约规定</strong> </p>
<p>前文提到，Java要求开发人员在重写 equals() 要同时重写 hashCode() ，符合Java对于 hashCode 的一般契约规定。除此之外，这里再说明一下其他原因。</p>
<p><strong>提高比较效率</strong> </p>
<p>以HashSet为例，Set作为集合是不允许保存具有相同内容的对象的，注意这里是相同内容，不是相同地址。这是因为在对象存储到Set中去重逻辑是这样的：</p>
<ol>
<li>先判断是否存在哈希值是否相同，如果哈希值不同，则表示是不同对象，即可将元素加入Set</li>
<li>如果哈希值相同，使用 equals() 判断是否存在内容相同，如果内容不同，则可加入Set，否则表示存在重复元素。</li>
</ol>
<p>先调用 hashCode() 方法可以减少调用 equals() 方法的次数，从而提高比较效率。</p>
<p><strong>防止不必要的bug</strong> </p>
<p>再来看一下只重写一个方法时，会有什么样的效果。</p>
<ol>
<li>只重写了 euqals() 不重写 hashCode()</li>
</ol>
<p>hashCode() 方法会为不同的对象返回不同的哈希值。如果有两个对象，它们的哈希值是不同的，但内容却相同。根据HashSet的去重逻辑，这两个对象是能被同时存储的Set中的，但这是不合理的，导致无法去重。</p>
<ol start="2">
<li>只重写了 hashCode() 不重写 euqals()</li>
</ol>
<p>Object类中的 equals() 会进行地址比较。如果有两个对象，它们的内容相同，重写 hashCode() 返回为它们返回相同的哈希值。根据HashSet的去重逻辑，哈希值相同时会调用 equals() 比较内容，但由于没有重写 equals() 导致返回了 false ，此时HashSet会认为它们的内容“不相同”，从而可以被同时存储的Set中的，但这是不合理的，导致无法去重。</p>
<p><strong>总的来说，同时重写 equals() 和 hashCode() 的原因主要有这么几点：</strong></p>
<ol>
<li><strong>符合Java hashCode的一般契约</strong></li>
<li><strong>提高比较效率</strong></li>
<li><strong>参照Map / Set 的去重逻辑，防止产生不必要的bug</strong> </li>
</ol>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p>本篇无总结。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>OOP</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>hashcode()</tag>
        <tag>equals()</tag>
      </tags>
  </entry>
</search>
