<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/03/12/HelloWorld/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<img src="/2022/03/12/HelloWorld/hello-world.png" class="" title="hello-world"> 

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>HelloWorld</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo&amp;Github搭建个人静态博客（Win）</title>
    <url>/2022/03/13/Hexo&amp;Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>Hexo是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<h1 id="1-什么是静态博客？"><a href="#1-什么是静态博客？" class="headerlink" title="1. 什么是静态博客？"></a>1. 什么是静态博客？</h1><p>所谓静态博客就是通过生成工具（例如Hexo；Halo等），直接将作者所书写的博文编译成最终的 html；css；js 等静态文件。作者/博主只需将生成的文件部署在服务器 面即可被在互联网中访问。 其他用户通过浏览器访问服务器就会浏览到博客啦。</p>
<h1 id="2-安装教程"><a href="#2-安装教程" class="headerlink" title="2. 安装教程"></a>2. 安装教程</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p>下载：<a href="https://nodejs.org/">Node.js 官网</a> | <a href="http://nodejs.cn/">Node.js 中文网</a> </p>
<p>安装：<a href="">我的安装教程</a> | <a href="http://nodejs.cn/learn">官方文档</a>  </p>
<h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p>下载：<a href="https://git-scm.com/">Git 官网</a> </p>
<p>安装：<a href="">我的安装教程</a> </p>
<h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><p>首先你需要有一个账号，关于Github账号的创建这里就不再赘述了。</p>
<h3 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h3><ol>
<li><p>创建仓库时需要注意，仓库名的格式必须是：<code>用户名.github.io</code>。其他选项可根据需要自行设置。</p>
<blockquote>
<img src="/2022/03/13/Hexo&Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/image-20220316104424889.png" class="" title="image-20220316104424889">
</blockquote>
</li>
<li><p>创建好仓库后，就可以使用地址访问了</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">https://用户名.github.io</span><br></pre></td></tr></table></figure>

<p>或者在你的仓库中进入Settings，在网页最下面Github Pages，点击进入就可以看到你的站点信息了。</p>
<blockquote>
<img src="/2022/03/13/Hexo&Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/image-20220316105310854.png" class="" title="image-20220316105310854"> 
</blockquote>
<blockquote>
<img src="/2022/03/13/Hexo&Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/image-20220316105332704.png" class="" title="image-20220316105332704">
</blockquote>
<blockquote>
<img src="/2022/03/13/Hexo&Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/image-20220316105439070.png" class="" title="image-20220316105439070">  </blockquote>
</li>
</ol>
<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p>本地环境与远程仓库准备好后就可以来安装和使用Hexo了，无论是安装还是后面的写作与部署可以参考<a href="https://hexo.io/zh-cn/docs/">官方文档</a> </p>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><ol>
<li><p>打开命令行窗口，在命令行中使用npm安装Hexo：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli </span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ol>
<li><p>选择一个目录用来保存网站资源，比如这里在桌面准备了一个 Blog 目录：</p>
<blockquote>
<img src="/2022/03/13/Hexo&Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/image-20220314211133967.png" class="" title="image-20220314211133967"> </blockquote>
</li>
<li><p>使用Git Bash进入该目录（在该目录下<code>右键 -&gt; Git Bash Here</code> 或者 <code>打开Git Bash Here使用命令进入指定目录</code> ）：</p>
<blockquote>
<img src="/2022/03/13/Hexo&Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/image-20220314211306592.png" class="" title="image-20220314211306592"> </blockquote>
</li>
<li><p>Git Bash中执行初始化命令可以生成站点所需要的的文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化站点文件</span></span><br><span class="line">hexo init</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">npm安装</span></span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ol>
<li><p>生成网页文件，Git Bash输入命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure></li>
<li><p>启动本地站点服务，Git Bash输入命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure></li>
<li><p>预览，浏览器地址栏输入：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">http://localhost:4000</span><br></pre></td></tr></table></figure>

<blockquote>
<img src="/2022/03/13/Hexo&Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/image-20220316102402450.png" class="" title="image-20220316102402450"> </blockquote>
</li>
</ol>
<h1 id="3-简单使用"><a href="#3-简单使用" class="headerlink" title="3. 简单使用"></a>3. 简单使用</h1><p>搭建好Hexo就可以编写自己的博客了，Hexo默认创建的是markdown格式的文件；</p>
<h2 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h2><ol>
<li><p>在Blog目录下启动Git Bash，并执行下面的命令会新建 <code>.md</code> 文件，默认（post布局）会存储在<code>source/_posts</code> 目录下，然后可以使用编写Markdown的软件编写你的文档了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建文档</span></span><br><span class="line">hexo new [layout] &lt;title&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># layout选项</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">post - 默认</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">page</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">draft</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写好文档后就可以生成网页文件以及预览了（见 <a href="#%E6%B5%8B%E8%AF%95">测试</a> ）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成网页文件</span></span><br><span class="line">hexo g</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动本地服务预览</span></span><br><span class="line">hexo s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">浏览器输入查看效果</span></span><br><span class="line">localhost:4000</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>生成网页文件后，除了本地预览，还可以部署到你的站点了</p>
<ol>
<li><p>安装git推送插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li>
<li><p>修改全局配置文件<code>_config.yml</code> </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在配置文件中找到deploy参数，并将参数值设为如下：</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:用户名/用户名.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>

<p>其中<code>repository</code> 值可以到Github博客仓库中复制：</p>
<blockquote>
<img src="/2022/03/13/Hexo&Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/image-20220316210812099.png" class="" title="image-20220316210812099"> </blockquote>
</li>
<li><p>推送文档</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>更换主题可以到 <a href="https://hexo.io/themes/">Hexo主题站</a> 浏览下载，关于主题的安装可参考主题文档（一般Github主题项目中都会有介绍），有时间的话我会再写一篇关于主题更换的博客。</p>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p><a href="https://hexo.io/zh-cn/docs/">Hexo官方文档 - 中文</a> </p>
<h2 id="Hexo命令"><a href="#Hexo命令" class="headerlink" title="Hexo命令"></a>Hexo命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装hexo</span></span><br><span class="line">npm install -g hexo-cli</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化</span></span><br><span class="line">hexo init </span><br><span class="line">npm install</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装推送插件</span></span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 新建文档 &amp; 草稿publish &amp; 生成网页文件 &amp; 本地预览 &amp; 推送文章</span></span></span><br><span class="line">hexo new &lt;title&gt; </span><br><span class="line">hexo publish &lt;title&gt;</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>



<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol>
<li>Github服务器位于国外，在国内访问速度受限，博客部署 <code>hexo d</code> 的时候经常会失败，这种情况就多部署几次直至成功就可以了。</li>
<li>如果嫌弃访问速度过慢可以用Gitee替换Github（搭建步骤基本一致）或者自行加速。</li>
<li>部署后站点内容可能不会立即刷新，稍等一会重新进入就可以了。</li>
</ol>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github Pages</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 对象拷贝.md</title>
    <url>/2022/04/26/Java%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h1 id="1-Java中创建对象的5种方式"><a href="#1-Java中创建对象的5种方式" class="headerlink" title="1. Java中创建对象的5种方式"></a>1. Java中创建对象的5种方式</h1><h2 id="1-1-new"><a href="#1-1-new" class="headerlink" title="1.1 new"></a>1.1 new</h2><p><code>new</code> 关键字创建对象是最常规的一种方法，可以通过调用有参或无参的构造方法实现对象的创建，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>

<h2 id="1-2-clazz-newInstance"><a href="#1-2-clazz-newInstance" class="headerlink" title="1.2 clazz.newInstance()"></a>1.2 clazz.newInstance()</h2><p>通过 <code>Class</code> 类的API实现创建对象，是一种反射方式。这种方式调用的是 public 无参构造，因此<strong>类必须具有公有的无参构造</strong>，否则会报错。</p>
<blockquote>
<p>这种方式在 Java 9 之后已经不推荐使用了：</p>
<img src="/2022/04/26/Java%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D/%E5%BC%83%E7%94%A8.png" class="" title="image-20220426113812098">  
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> Student.class.newInstance(); <span class="comment">// 方式一</span></span><br><span class="line"></span><br><span class="line"><span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> (Student) Class.forName(<span class="string">&quot;my.finn.Student&quot;</span>).newInstance(); <span class="comment">// 方式二</span></span><br></pre></td></tr></table></figure>

<h2 id="1-3-constructor-newInstance"><a href="#1-3-constructor-newInstance" class="headerlink" title="1.3 constructor.newInstance()"></a>1.3 constructor.newInstance()</h2><p> java.lang.reflect.Constructor 类中也有一个 newInstance() 方法可以创建对象，和上一个方法一样，也是一种反射方式。通过这个方法<strong>可以调用无/有参和公/私有的构造方法</strong>。</p>
<blockquote>
<p>实际上 clazz.newInstance() 内部仍然是调用的 constructor.newInstance()</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constructor&lt;?&gt;[] declaredConstructors = Student.class.getDeclaredConstructors(); <span class="comment">// 获取所有构造方法</span></span><br><span class="line"></span><br><span class="line">Constructor&lt;?&gt;[] publicConstructors = Student.class.getConstructors(); <span class="comment">// 获取public的构造方法</span></span><br><span class="line"></span><br><span class="line">Constructor&lt;?&gt; constructor = declaredConstructors[<span class="number">0</span>]; <span class="comment">// 从数组中获取要使用的构造方法</span></span><br><span class="line"></span><br><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> (Student)constructor.newInstance(); <span class="comment">// 创建对象，newInstance中需要填入相应构造方法的参数</span></span><br></pre></td></tr></table></figure>

<h2 id="1-4-Clone"><a href="#1-4-Clone" class="headerlink" title="1.4 Clone"></a>1.4 Clone</h2><p>Object类中提供了一个 native 的 clone() 方法，A.clone() 会创建一个内容和对象 A 相同的对象，使用该方式<strong>不会调用构造方法</strong>。</p>
<blockquote>
<p>protected native Object clone() throws CloneNotSupportedException;</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> s1.clone();</span><br></pre></td></tr></table></figure>

<h2 id="1-5-反序列化"><a href="#1-5-反序列化" class="headerlink" title="1.5 反序列化"></a>1.5 反序列化</h2><p>反序列化是把磁盘文件中的对象数据或者把网络节点上的对象数据，恢复成Java对象模型的过程，反序列化<strong>不会调用任何构造函数</strong>。</p>
<h1 id="2-对象拷贝"><a href="#2-对象拷贝" class="headerlink" title="2. 对象拷贝"></a>2. 对象拷贝</h1><h2 id="2-1-引用拷贝"><a href="#2-1-引用拷贝" class="headerlink" title="2.1 引用拷贝"></a>2.1 引用拷贝</h2><p><strong>引用拷贝：创建一个引用，该引用与原引用都指向同一个对象。</strong> </p>
<img src="/2022/04/26/Java%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D/%E5%BC%95%E7%94%A8%E6%8B%B7%E8%B4%9D.png" class="" title="引用拷贝"> 

<h2 id="2-2-浅拷贝"><a href="#2-2-浅拷贝" class="headerlink" title="2.2 浅拷贝"></a>2.2 浅拷贝</h2><p><strong>浅拷贝：创建一个引用，并对对象进行拷贝，将创建的引用指向拷贝对象，拷贝时：</strong></p>
<ul>
<li><strong>基本数据类型的字段进行值复制</strong> </li>
<li><strong>引用类型的字段复制一份引用并指向原引用所指向的对象</strong> </li>
</ul>
<img src="/2022/04/26/Java%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D/%E6%B5%85%E6%8B%B7%E8%B4%9D.png" class="" title="浅拷贝"> 

<h2 id="2-3-深拷贝"><a href="#2-3-深拷贝" class="headerlink" title="2.3 深拷贝"></a>2.3 深拷贝</h2><p><strong>深拷贝：创建一个引用，并对对象进行拷贝，将创建的引用指向拷贝对象，拷贝时：</strong></p>
<ul>
<li><strong>基本数据类型的字段进行值复制</strong> </li>
<li><strong>引用类型的字段将引用和引用的对象都复制一份，并将拷贝引用指向拷贝对象</strong> </li>
</ul>
<blockquote>
<p>实现深拷贝的方法：</p>
<ul>
<li>反序列化</li>
<li>重写clone()方法时把属性拷贝</li>
</ul>
</blockquote>
<img src="/2022/04/26/Java%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D/%E6%B7%B1%E6%8B%B7%E8%B4%9D.png" class="" title="深拷贝"> 

<h1 id="3-示例"><a href="#3-示例" class="headerlink" title="3 示例"></a>3 示例</h1><h2 id="Person-class"><a href="#Person-class" class="headerlink" title="Person.class"></a>Person.class</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age, Address address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//省略setter/getter</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123; <span class="comment">//实现Cloneable接口中的clone()方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone(); <span class="comment">//默认浅拷贝</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">(<span class="type">boolean</span> b)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123; <span class="comment">// 深拷贝(为了方便测试这里就直接重载)</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) <span class="built_in">this</span>.clone();</span><br><span class="line">        p.address = (Address) <span class="built_in">this</span>.address.clone();</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Address-class"><a href="#Address-class" class="headerlink" title="Address.class"></a>Address.class</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Address</span><span class="params">(String city)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.city = city;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略setter/getter</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Main-class"><a href="#Main-class" class="headerlink" title="Main.class"></a>Main.class</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Address</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;China&quot;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Finn&quot;</span>, <span class="number">18</span>, address);</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">clonedPerson</span> <span class="operator">=</span> person; <span class="comment">// 引用拷贝</span></span><br><span class="line">        System.out.println(<span class="string">&quot;**************** 引用拷贝 ****************&quot;</span>);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">        System.out.println(clonedPerson);</span><br><span class="line">        System.out.println(person.getAddress());</span><br><span class="line">        System.out.println(clonedPerson.getAddress());</span><br><span class="line"></span><br><span class="line">        clonedPerson = (Person) person.clone(); <span class="comment">// 浅拷贝</span></span><br><span class="line">        System.out.println(<span class="string">&quot;**************** 浅拷贝 ****************&quot;</span>);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">        System.out.println(clonedPerson);</span><br><span class="line">        System.out.println(person.getAddress());</span><br><span class="line">        System.out.println(clonedPerson.getAddress());</span><br><span class="line"></span><br><span class="line">        clonedPerson = (Person) person.clone(<span class="literal">true</span>); <span class="comment">// 深拷贝</span></span><br><span class="line">        System.out.println(<span class="string">&quot;**************** 深拷贝 ****************&quot;</span>);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">        System.out.println(clonedPerson);</span><br><span class="line">        System.out.println(person.getAddress());</span><br><span class="line">        System.out.println(clonedPerson.getAddress());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Print"><a href="#Print" class="headerlink" title="Print"></a>Print</h2><img src="/2022/04/26/Java%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D/%E6%8B%B7%E8%B4%9D%E6%89%93%E5%8D%B0%E7%A4%BA%E4%BE%8B.png" class="" title="拷贝打印示例"> 

<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h1><ol>
<li><p>java中创建对象的几种方式</p>
<blockquote>
<ul>
<li>new</li>
<li>clazz.newInstance(); // java 9 开始弃用</li>
<li>constructor.newInstance();</li>
<li>obj.clone(); // 默认浅拷贝</li>
<li>deseriallization </li>
</ul>
</blockquote>
</li>
<li><p>拷贝</p>
<blockquote>
<ul>
<li>引用拷贝：创建一个引用指向原对象</li>
<li>浅拷贝：基本类型进行值复制；引用类型只复制引用，不复制引用的对象；clone()方法默认采用浅拷贝实现</li>
<li>深拷贝：基本类型进行值复制；引用类型既复制引用，也复制引用的对象</li>
</ul>
</blockquote>
</li>
<li><p>实现深拷贝</p>
<blockquote>
<ul>
<li>序列化与反序列化</li>
<li>重写clone()方法时把属性也拷贝</li>
</ul>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>OOP</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>深浅拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>Java hashCode()与equals()</title>
    <url>/2022/04/30/hashCode%E6%96%B9%E6%B3%95%E4%B8%8Eequals%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>Java中有一个顶级父类 <code>Object</code> ，Java 允许把任何类型的对象赋给 Object 类型的变量。当一个类被定义后，如果没有指定继承的父类，那么默认父类就是 Object 类。今天就来聊聊Object类中两个方法：<code>equals()</code> 和 <code>hashCode()</code> 。</p>
<h1 id="1-equals"><a href="#1-equals" class="headerlink" title="1. equals()"></a>1. equals()</h1><p><code>equals()</code> 用来比较两个对象之间的是否相等。它的源码（JDK11）如下：</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Indicates whether some other object is &quot;equal to&quot; this one.</span></span><br><span class="line"><span class="comment">The equals method implements an equivalence relation on non-null object references:</span></span><br><span class="line"><span class="comment">It is reflexive: for any non-null reference value x, x.equals(x) should return true.</span></span><br><span class="line"><span class="comment">It is symmetric: for any non-null reference values x and y, x.equals(y) should return true if and only if y.equals(x) returns true.</span></span><br><span class="line"><span class="comment">It is transitive: for any non-null reference values x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true.</span></span><br><span class="line"><span class="comment">It is consistent: for any non-null reference values x and y, multiple invocations of x.equals(y) consistently return true or consistently return false, provided no information used in equals comparisons on the objects is modified.</span></span><br><span class="line"><span class="comment">For any non-null reference value x, x.equals(null) should return false.</span></span><br><span class="line"><span class="comment">The equals method for class Object implements the most discriminating possible equivalence relation on objects; that is, for any non-null reference values x and y, this method returns true if and only if x and y refer to the same object (x == y has the value true).</span></span><br><span class="line"><span class="comment">Note that it is generally necessary to override the hashCode method whenever this method is overridden, so as to maintain the general contract for the hashCode method, which states that equal objects must have equal hash codes.</span></span><br><span class="line"><span class="comment">Params:</span></span><br><span class="line"><span class="comment">obj – the reference object with which to compare.</span></span><br><span class="line"><span class="comment">Returns:</span></span><br><span class="line"><span class="comment">true if this object is the same as the obj argument; false otherwise.</span></span><br><span class="line"><span class="comment">See Also: hashCode(), java.util.HashMap</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;<span class="keyword">return</span> (<span class="built_in">this</span> == obj);&#125;</span><br></pre></td></tr></table></figure>

<p>【注释文档翻译】</p>
<p>表示其他对象是否 “等于”这个对象。equals方法实现了对非空对象引用的等价关系。</p>
<p>它是自反的：对于任何非空的引用值 x，x.equals(x) 应该返回 true。<br>它是对称的：对于任何非空的引用值 x 和 y，x.equals(y) 应该返回 true，当且仅当 y.equals(x) 返回 true。<br>它是传递的：对于任何非空参考值 x、y 和 z，如果 x.equals(y) 返回 true，y.equals(z) 返回 true ，那么 x.equals(z) 应该返回 true。<br>它是一致的：对于任何非空的参考值 x 和 y，如果没有修改对象上的等价比较信息，多次调用 x.equals(y) 一致地返回 true 或一致地返回 false。</p>
<p>对于任何非空的引用值 x，x.equals(null) 应该返回 false。</p>
<p>Object类的 equals 方法在对象上实现了最有鉴别力的等价关系；也就是说，对于任何非空的引用值 x 和 y ，当且仅当 x 和 y 指向同一个对象时，该方法返回 true（x == y的值为true）。</p>
<p><strong>请注意，一般来说，只要重写这个方法，就必须重写hashCode方法，这样才能保持hashCode方法的一般契约，即相等的对象必须有相等的哈希代码。</strong> </p>
<p>参数：obj - 与之比较的参考对象。</p>
<p>返回：true 如果这个对象与obj 参数相同；否则为false。</p>
<p>参见：hashCode(), java.util.HashMap</p>
</blockquote>
<p>可以看到，注释文档已经把 equals() 介绍的很详细了，主要总结为一下几点：</p>
<ol>
<li><strong>用来判断对象的等价关系</strong></li>
<li><strong>具有自反性、对称性、传递性、一致性</strong></li>
<li><strong>调用该方法的对象不能为空，否则会报空指针异常（NullPointerException, NPE）</strong></li>
<li><strong>对于任何非空的引用值 x 和 y ，当且仅当 x 和 y 指向同一个对象时，该方法返回 true</strong></li>
<li><strong>重写equals()时必须重写hashCode()</strong> </li>
</ol>
<hr>
<p>对于前两点就不在多解释了，值得注意的是第3点，我们在IDEA（v2021.2）上使用空引用调用equals()时编译器并不会直接标红报错，而是会标黄。这种情况下不影响编译器编译，但在程序运行时会报错，在编写程序时要注意。</p>
<p>比如在进行String对象与字符串比较时通常把已确定的字符串放在前，把String对象作equals()的参数传入，即：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str= <span class="string">&quot;Hello World&quot;</span></span><br><span class="line"><span class="string">&quot;Hello World&quot;</span>.equals(str);</span><br></pre></td></tr></table></figure>

<hr>
<p>关于第4点，在源码中可以看到Object类中的equals()判断使用的是 <code>==</code> 。关于 == 运算符：</p>
<ul>
<li> 判断基本数据类型时，是判断的值是否相同</li>
<li>判断引用数据类型时，是比较是否指向同一对象，亦即地址值是否相同</li>
</ul>
<p>但是在业务中我们通常需要判断两个对象是否具有相同的内容，此时使用 == 就不能满足要求了，因此才需要通过重写euqals()来实现这样的逻辑，这也是 <code>==</code> 与 <code>equals()</code> 区别的根本所在。比如String类中的重写</p>
<img src="/2022/04/30/hashCode%E6%96%B9%E6%B3%95%E4%B8%8Eequals%E6%96%B9%E6%B3%95/StringEquals.png" class="" title="StringEquals"> 

<hr>
<p>关于第5点，重写equals()时必须重写hashCode()，文档中说明了是为了“保持hashCode方法的一般契约，即相等的对象必须有相等的哈希代码”。更多原因可以继续参考 <em>3. 为什么要同时重写equals()和hashCode()？</em> 详细理解。</p>
<h1 id="2-hashCode"><a href="#2-hashCode" class="headerlink" title="2. hashCode()"></a>2. hashCode()</h1><p><code>hashCode()</code> 用来返回该对象的哈希代码值（一个整数）。它的源码（JDK11）如下：</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Returns a hash code value for the object. This method is supported for the benefit of hash tables such as those provided by java.util.HashMap.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The general contract of hashCode is:</span></span><br><span class="line"><span class="comment">- Whenever it is invoked on the same object more than once during an execution of a Java application, the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application.</span></span><br><span class="line"><span class="comment">- If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result.</span></span><br><span class="line"><span class="comment">- It is not required that if two objects are unequal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce distinct integer results. However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hash tables.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">As much as is reasonably practical, the hashCode method defined by class Object does return distinct integers for distinct objects. (The hashCode may or may not be implemented as some function of an object&#x27;s memory address at some point in time.)</span></span><br><span class="line"><span class="comment">Returns:</span></span><br><span class="line"><span class="comment">a hash code value for this object.</span></span><br><span class="line"><span class="comment">See Also:</span></span><br><span class="line"><span class="comment">equals(Object), System.identityHashCode</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>【注释文档翻译】</p>
<p>返回该对象的哈希代码值。支持这个方法是为了让哈希表受益，比如java.util.HashMap提供的哈希表。</p>
<p>hashCode的一般契约是：</p>
<ul>
<li>在一个Java应用程序的执行过程中，无论何时对同一个对象调用多次，hashCode方法都必须一致地返回相同的整数，前提是在对象的等价比较中使用的信息没有被修改。这个整数不需要在一个应用程序的执行过程中与同一应用程序的另一个执行过程保持一致。</li>
<li>如果两个对象根据equals(Object)方法是相等的，那么在这两个对象上调用hashCode方法必须产生相同的整数结果。</li>
<li>如果根据equals(Object)方法，两个对象不相等，那么在这两个对象上调用hashCode方法必须产生不同的整数结果，这一点并不要求。然而，程序员应该知道，为不相等的对象产生不同的整数结果可能会提高哈希表的性能。</li>
</ul>
<p>在合理可行的情况下，由Object类定义的hashCode方法确实为不同的对象返回不同的整数。(hashCode可能是也可能不是在某个时间点作为对象的内存地址的某个函数来实现)。</p>
<p>Return：该对象的哈希代码值<br>也请参见：equals(Object), System.identityHashCode</p>
</blockquote>
<p>从源码可以看到，Object类中的 hashCode() 是一个 <code>native</code> 方法。文档中也说明了前文提到的“hashCode的一般契约”，可以总结为一下几点：</p>
<ol>
<li>在同一次的应用执行过程中，同一个对象多次调用 hashCode() 返回的结果不变</li>
<li>equals() 返回 true 时，两个对象的 hashCode() 返回的结果必须相同（为同一个整数）</li>
<li>equals() 返回 false 时，两个对象的 hashCode() 返回的结果可以相同，但为不相等的对象产生不同的整数结果可能会提高哈希表的性能</li>
<li>在合理可行的情况下，由Object类定义的 hashCode() 确实为不同的对象返回不同的整数</li>
</ol>
<p>第4点就是为什么重写 equals() 时也要重写hashCode()的根本所在，可以参考这里 <em>3.为什么要同时重写equals()和hashCode()？</em> 详细理解。</p>
<h1 id="3-equals-与-的区别"><a href="#3-equals-与-的区别" class="headerlink" title="3. equals() 与 == 的区别"></a>3. equals() 与 == 的区别</h1><p>首先需要明确的是 <code>==</code> 是关系运算符，而 <code>equals()</code> 是方法，从这一点上就可以总结出二者的区别。</p>
<p>== 作为关系运算符在Java语法中具有通用性，换句话说既可以用来比较基本数据类型，也可以比较引用类型：</p>
<ul>
<li> 判断基本类型时，是判断的值是否相同</li>
<li>判断引用类型时，是比较是否指向同一对象，亦即地址值是否相同</li>
</ul>
<p>而 euqals() 归根是一个方法，因此对于基本类型来说是不存在调用方法这种行为的，它只能被一个对象实例调用。</p>
<p>Object类中的 equals() 逻辑是用 == 实现的，此时比较的是两个引用所指向的地址：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;<span class="keyword">return</span> (<span class="built_in">this</span> == obj);&#125;</span><br></pre></td></tr></table></figure>

<p>如果要实现判断两个对象内容是否相同时，需要对 equals() 重写，如String类中通过重写实现了两个字符串内容的比较。</p>
<h1 id="4-为什么要同时重写-equals-和-hashCode-？"><a href="#4-为什么要同时重写-equals-和-hashCode-？" class="headerlink" title="4. 为什么要同时重写 equals() 和 hashCode() ？"></a>4. 为什么要同时重写 equals() 和 hashCode() ？</h1><p><strong>符合Java对于 hashCode 的一般契约规定</strong> </p>
<p>前文提到，Java要求开发人员在重写 equals() 要同时重写 hashCode() ，符合Java对于 hashCode 的一般契约规定。除此之外，这里再说明一下其他原因。</p>
<p><strong>提高比较效率</strong> </p>
<p>以HashSet为例，Set作为集合是不允许保存具有相同内容的对象的，注意这里是相同内容，不是相同地址。这是因为在对象存储到Set中去重逻辑是这样的：</p>
<ol>
<li>先判断是否存在哈希值是否相同，如果哈希值不同，则表示是不同对象，即可将元素加入Set</li>
<li>如果哈希值相同，使用 equals() 判断是否存在内容相同，如果内容不同，则可加入Set，否则表示存在重复元素。</li>
</ol>
<p>先调用 hashCode() 方法可以减少调用 equals() 方法的次数，从而提高比较效率。</p>
<p><strong>防止不必要的bug</strong> </p>
<p>再来看一下只重写一个方法时，会有什么样的效果。</p>
<ol>
<li>只重写了 euqals() 不重写 hashCode()</li>
</ol>
<p>hashCode() 方法会为不同的对象返回不同的哈希值。如果有两个对象，它们的哈希值是不同的，但内容却相同。根据HashSet的去重逻辑，这两个对象是能被同时存储的Set中的，但这是不合理的，导致无法去重。</p>
<ol start="2">
<li>只重写了 hashCode() 不重写 euqals()</li>
</ol>
<p>Object类中的 equals() 会进行地址比较。如果有两个对象，它们的内容相同，重写 hashCode() 返回为它们返回相同的哈希值。根据HashSet的去重逻辑，哈希值相同时会调用 equals() 比较内容，但由于没有重写 equals() 导致返回了 false ，此时HashSet会认为它们的内容“不相同”，从而可以被同时存储的Set中的，但这是不合理的，导致无法去重。</p>
<p><strong>总的来说，同时重写 equals() 和 hashCode() 的原因主要有这么几点：</strong></p>
<ol>
<li><strong>符合Java hashCode的一般契约</strong></li>
<li><strong>提高比较效率</strong></li>
<li><strong>参照Map / Set 的去重逻辑，防止产生不必要的bug</strong> </li>
</ol>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p>本篇无总结。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>OOP</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>hashcode()</tag>
        <tag>equals()</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList扩容机制</title>
    <url>/2022/05/06/ArrayList%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="1-ArrayList简介"><a href="#1-ArrayList简介" class="headerlink" title="1. ArrayList简介"></a>1. ArrayList简介</h1><p><code>ArrayList</code> 是Collection接口的子接口List的主要实现类，源码部分如下（本文所展示的源码为<strong>JDK11</strong>版本，与JDK8略有不同）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;</span><br><span class="line">    <span class="comment">/* 属性 */</span></span><br><span class="line">    <span class="comment">// 序列化ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8683452581122892189L</span>;</span><br><span class="line">    </span><br><span class="line">   	<span class="comment">// 默认容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空数组 EMPTY_ELEMENTDATA</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空数组 DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Object数组，用来存储元素</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// size = 列表中当前元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 方法 */</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从成员方法中可以看到，设置了默认容量 <code>DEFAULT_CAPACITY = 10</code> ； 底层数据结构是 <code>Object[]</code> 数组，因此支持随机访问，适用于频繁的查找工作 。由于数组是连续内存空间，插入或删除（除尾操作外）一个元素需要移动其他元素，所以不适合在插入和删除操作频繁的场景下使用。</p>
<p>ArrayList中还定义了两个空数组 <code>EMPTY_ELEMENTDATA</code> 和 <code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code> ，这两个static数组结构完全一样，明明是一样的为什么要定义两个不同的呢？文档中对DEFAULTCAPACITY_EMPTY_ELEMENTDATA是这样解释的：</p>
<blockquote>
<p>Shared empty array instance used for default sized empty instances. We distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when first element is added.</p>
<p>用于默认大小的空实例的共享空数组实例。我们将其与EMPTY_ELEMENTDATA区分开来，以便知道添加第一个元素时应该膨胀多少。</p>
</blockquote>
<p>另外，<strong>ArrayList是线程不安全的</strong>。和Vector不同的是，ArrayList的成员方法并没有使用 <code>synchronized</code> ，而Vector中对可能设计线程安全问题的操作都进行了synchronized。</p>
<p>ArrayList的底层是使用数组实现，数组使用时是固定容量大小的，而ArrayList容量可以随着元素的增加而自动增加，因此不用担心ArrayList容量不足的问题。这里就涉及到了ArrayList的扩容了，下面就结合源码对扩容机制进行详细地分析，看看ArrayList是如何扩容的。</p>
<h1 id="2-ArrayList构造方法"><a href="#2-ArrayList构造方法" class="headerlink" title="2. ArrayList构造方法"></a>2. ArrayList构造方法</h1><h2 id="2-1-无参构造"><a href="#2-1-无参构造" class="headerlink" title="2.1 无参构造"></a>2.1 无参构造</h2><p>源码（JDK 11）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无参构造逻辑非常简单，将 <code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code> 赋值给了 <code>elementData</code> ，即通过无参构造方法创建的ArrayList实例的elementData是一个空数组。</p>
<blockquote>
<p>此时列表 <code>capacity == 0</code> and <code>size == 0</code> 。</p>
</blockquote>
<h2 id="2-2-有参构造之容量参数"><a href="#2-2-有参构造之容量参数" class="headerlink" title="2.2 有参构造之容量参数"></a>2.2 有参构造之容量参数</h2><p>源码（JDK 11）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span> + initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList提供了传递容量值的有参构造，可以通过参数 <code>initialCapacity</code> 指定列表初始容量。该构造方法的逻辑解释如下：</p>
<ol>
<li><p>如果 <code>initialCapacity &gt; 0</code> ，则创建一个容量为 initialCapacity  的 <code>Object[]</code> ，并赋值给 <code>elementData</code> ；</p>
<blockquote>
<p>此时列表 capacity == initialCapacity  and size == 0</p>
</blockquote>
</li>
<li><p>如果  <code>initialCapacity == 0</code> ，则将空数组 <code>EMPTY_ELEMENTDATA</code> 赋值给 <code>elementData</code> （这里的空数组与无参构造中的不同）；</p>
<blockquote>
<p>此时列表 capacity == 0 and size == 0</p>
</blockquote>
</li>
<li><p>如果 <code>initialCapacity &lt; 0</code> ，则抛出非法参数异常，因为容量不能为负。</p>
</li>
</ol>
<h2 id="2-3-有参构造之集合参数"><a href="#2-3-有参构造之集合参数" class="headerlink" title="2.3 有参构造之集合参数"></a>2.3 有参构造之集合参数</h2><p>源码（JDK 11）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = a.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c.getClass() == ArrayList.class) &#123;</span><br><span class="line">            elementData = a;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            elementData = Arrays.copyOf(a, size, Object[].class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList允许使用Collection类型构造实例，该方法构造一个包含指定集合元素的列表，按照集合的迭代器返回元素的顺序排列。</p>
<h1 id="3-ArrayList数组扩容"><a href="#3-ArrayList数组扩容" class="headerlink" title="3. ArrayList数组扩容"></a>3. ArrayList数组扩容</h1><p>创建好ArrayList实例后，添加元素时，当列表容量不足时会对列表进行扩容，这要从ArrayList的 <code>add()</code> 方法讲起，来看看它是如何实现的。</p>
<img src="/2022/05/06/ArrayList%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/add%E6%96%B9%E6%B3%95.png" class="" title="add方法"> 

<p>ArrayList类中有2个 add()：</p>
<ol>
<li><code>void add(E e, Object[] elementData, int s)</code> 该方法是 private 的，不能被外部调用，该方法是将元素 <code>e</code> 插入到 <code>Object[]</code> 的索引 <code>s</code> 处</li>
<li><code>boolean add(E e)</code> 该方法是将元素 e 添加到列表尾部</li>
<li><code>boolean add(int index, E element)</code> 该方法是将元素 <code>element</code> 插入到指定索引 <code>index</code> 处</li>
</ol>
<p>显然，添加元素就会涉及到扩容问题（容量不足的情况下）。</p>
<h2 id="3-1-添加元素"><a href="#3-1-添加元素" class="headerlink" title="3.1 添加元素"></a>3.1 添加元素</h2><h3 id="（1）-boolean-add-E-e"><a href="#（1）-boolean-add-E-e" class="headerlink" title="（1） boolean add(E e)"></a>（1） boolean add(E e)</h3><p>add(E e) 方法逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    modCount++; <span class="comment">// 计数器</span></span><br><span class="line">    add(e, elementData, size); <span class="comment">// 调用private add()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有 add()</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e, Object[] elementData, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == elementData.length)</span><br><span class="line">        elementData = grow(); <span class="comment">// 扩容</span></span><br><span class="line">    elementData[s] = e; <span class="comment">// 添加元素</span></span><br><span class="line">    size = s + <span class="number">1</span>; <span class="comment">// size + 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>add(E e)</code> 中调用了私有的 <code>add(E e, Object[] elementData, int s)</code> 方法来添加元素，其中参数 s 传入了 size 。</p>
<blockquote>
<p><strong>void add(E e, Object[] elementData, int s)</strong> </p>
<ol>
<li><code>size</code> 与数组长度 <code>elementData.length</code> 比较。如果相等，则执行 <strong>2.</strong> ；不相等，则执行 <strong>3.</strong> </li>
<li>数组已满，需要进行扩容（ <code>grow()</code> ）</li>
<li>数组不满，直接将元素添加</li>
</ol>
</blockquote>
<h3 id="（2）-boolean-add-int-index-E-element"><a href="#（2）-boolean-add-int-index-E-element" class="headerlink" title="（2） boolean add(int index, E element)"></a>（2） boolean add(int index, E element)</h3><p>add(int index, E element) 方法逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    rangeCheckForAdd(index); <span class="comment">// 检查索引</span></span><br><span class="line">    modCount++; <span class="comment">// 计数器</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> s;</span><br><span class="line">    Object[] elementData;</span><br><span class="line">    <span class="keyword">if</span> ((s = size) == (elementData = <span class="built_in">this</span>.elementData).length) <span class="comment">// 判断数组是否满</span></span><br><span class="line">        elementData = grow(); <span class="comment">// 扩容</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, s - index); <span class="comment">// 移动元素</span></span><br><span class="line">    elementData[index] = element; <span class="comment">// index处插入</span></span><br><span class="line">    size = s + <span class="number">1</span>; <span class="comment">// size + 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查索引</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheckForAdd</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>add(int index, E element)</code> 调用了 <code>rangeCheckForAdd(int index)</code> 来检查索引的合法性，非法索引会抛出异常。index 合法后会判断 size 与 length ，在数组满存的情况下调用 <code>grow()</code> 方法进行扩容。如果空间足够就会进行元素插入，与（1）方法中不同的是，该 add 是插入元素到指定 index ，因此会涉及元素移动。</p>
<p>可以看到，（1）（2）两个 add() 方法中都调用了 <code>grow()</code> 进行扩容，下面就来看一下这个方法的具体实现。</p>
<h2 id="3-2-扩容方法"><a href="#3-2-扩容方法" class="headerlink" title="3.2 扩容方法"></a>3.2 扩容方法</h2><p>扩容方法 <code>grow()</code> 源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object[] grow() &#123;</span><br><span class="line">    <span class="keyword">return</span> grow(size + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object[] grow(<span class="type">int</span> minCapacity) &#123;</span><br><span class="line">	<span class="type">return</span> <span class="variable">elementData</span> <span class="operator">=</span> Arrays.copyOf(elementData, newCapacity(minCapacity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  ArrayList中重载了grow()方法，无参 <code>grow()</code> 调用了有参 <code>grow(int minCapacity)</code> 。</p>
<blockquote>
<p><strong>Object[] grow(int minCapacity)</strong> </p>
<p>- <code>minCapacity</code> 能够成功添加元素的最小容量</p>
<p>- <code>return</code>  返回一个具有新容量的数组，新容量通过 <code>newCapacity()</code> 方法计算</p>
</blockquote>
<p>再来看一下 <code>newCapacity()</code> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">newCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length; <span class="comment">// 旧容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>); <span class="comment">// 新容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) <span class="comment">// 如果 elementData 是由无参构造创建</span></span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (newCapacity - MAX_ARRAY_SIZE &lt;= <span class="number">0</span>) ? newCapacity : hugeCapacity(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>int newCapacity(int minCapacity)</strong> </p>
<ol>
<li>使用旧容量 <code>oldCapacity</code> 计算新容量 <code>newCapacity</code> </li>
<li>比较  <code>newCapacity</code> 与 <code>minCapacity</code> ，若  <code>newCapacity &gt; minCapacity </code> ，则 <code>return</code> ；否则，执行 <strong>3.</strong> </li>
<li>判断 <code>elementData</code> 是否是由无参构造方法创建，若是，则 <code>return</code> ；否则，执行 <strong>4.</strong> </li>
<li>判断 <code>minCapacity</code> 是否合法，若 <code>&lt; 0</code> ，抛出异常 <code>OutOfMemoryError</code> ；否则，<code>return minCapacity</code> </li>
</ol>
</blockquote>
<p>从源码中可以看到，新的容量是以数组长度为基础进行计算的。<code>oldCapacity &gt;&gt; 1</code> 中涉及到了右移运算，对于一个正数来说，内存中已二进制进行存储，右移 1 位相当于缩小为原来的 1/2，<strong>因此 new 与 old 之间存在 <code>newCapacity = 1.5 * oldCapacity</code> 的关系</strong> 。</p>
<p>其次，源码中对不同情况下有不同的 <code>return</code> ，下面通过例子对这些情况进行详细说明。根据不同构造方法，<code>elementData</code> 可以细分为以下情况：</p>
<ol>
<li>elementData = {}<ol>
<li>elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</li>
<li>elementData == EMPTY_ELEMENTDATA : ArrayList(int initialCapacity)</li>
<li>elementData == EMPTY_ELEMENTDATA : ArrayList(Collection&lt;? extends E&gt; c)</li>
</ol>
</li>
<li>elementData != {}<ol>
<li>一般的非空数组</li>
<li>Collection转换的非空数组</li>
</ol>
</li>
</ol>
<blockquote>
<p>1.2和1.3在扩容时属于同一种情况，2.1和2.2属于同一种，因此扩容时可以分为三种情况讨论，这一点从<code>newCapacity()</code> 中可以判断。</p>
</blockquote>
<h2 id="3-3-扩容分析"><a href="#3-3-扩容分析" class="headerlink" title="3.3 扩容分析"></a>3.3 扩容分析</h2><h3 id="1）elementData-DEFAULTCAPACITY-EMPTY-ELEMENTDATA"><a href="#1）elementData-DEFAULTCAPACITY-EMPTY-ELEMENTDATA" class="headerlink" title="1）elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA"></a>1）elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</h3><p>ArrayList中定义了两种 <code>static final object[]</code> ，前面提到两个一样的空数组是为了区分使用不同的扩容规则，当ArrayList使用无参构造 <code>ArrayList()</code> 创建实例时，<code>elementData</code> 会被赋值为 <code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code> 。</p>
<p>当ArrayList首次添加元素时（下述中的 <code>=</code> 为数学逻辑）：</p>
<ul>
<li><p>size = 0, minCapacity = size + 1 = 1, oldCapacity = elementData.length = 0, newCapacity = 0</p>
<p>=&gt; newCapacity - minCapacity &lt; 0,  DEFAULTCAPACITY_EMPTY_ELEMENTDATA</p>
<p>=&gt; return Math.max(DEFAULT_CAPACITY, minCapacity), DEFAULT_CAPACITY = 10</p>
<p>=&gt; return DEFAULT_CAPACITY</p>
<p>=&gt; elementData.length = 10</p>
</li>
</ul>
<p>无参构造下的空 ArrayList <strong>首次</strong>添加元素，elementData 扩容为10。待数组满存，再添加元素时：</p>
<ul>
<li><p>size = 10, minCapacity = size + 1 = 11, oldCapacity = elementData.length = 10, newCapacity = 15</p>
<p>=&gt; newCapacity - minCapacity &gt; 0</p>
<p>=&gt; return newCapacity</p>
<p>=&gt; elementData.length = 15</p>
</li>
</ul>
<p>elementData 按原容量的1.5倍扩容，并且容易得到，再下次扩容规则也是1.5倍。</p>
<h3 id="2）elementData-EMPTY-ELEMENTDATA"><a href="#2）elementData-EMPTY-ELEMENTDATA" class="headerlink" title="2）elementData == EMPTY_ELEMENTDATA"></a>2）elementData == EMPTY_ELEMENTDATA</h3><p>当ArrayList使用有参构造 <code>ArrayList(int initialCapacity) </code> 和 <code>ArrayList(Collection&lt;? extends E&gt; c)</code> 创建实例时，若 <code>initialCapacity == 0</code> 或 <code>c.toArray().length == 0</code> ，<code>elementData</code> 会被赋值为 <code>EMPTY_ELEMENTDATA</code> 。</p>
<p>当ArrayList首次添加元素时：</p>
<ul>
<li><p>size = 0, minCapacity = size + 1 = 1, oldCapacity = elementData.length = 0, newCapacity = 0</p>
<p>=&gt; newCapacity - minCapacity &lt; 0, EMPTY_ELEMENTDATA, minCapacity &gt; 0</p>
<p>=&gt; return minCapacity</p>
<p>=&gt; elementData.length = 1</p>
</li>
</ul>
<p>有参构造下的空 ArrayList <strong>首次</strong>添加元素，扩容为 minCapacity = 1。待数组满存，再添加元素时：</p>
<ul>
<li><p>size = 1, minCapacity = size + 1 = 2, oldCapacity = elementData.length = 1, newCapacity = 1</p>
<p>=&gt; newCapacity - minCapacity &lt; 0, minCapacity &gt; 0</p>
<p>=&gt; return minCapacity</p>
<p>=&gt; elementData.length = 2</p>
</li>
<li><p>size = 2, minCapacity = size + 1 = 3, oldCapacity = elementData.length = 2, newCapacity = 3</p>
<p>=&gt; newCapacity - minCapacity = 0, minCapacity &gt; 0</p>
<p>=&gt; return minCapacity</p>
<p>=&gt; elementData.length = 3</p>
</li>
<li><p>size = 3, minCapacity = size + 1 = 4, oldCapacity = elementData.length = 3, newCapacity = 4</p>
<p>=&gt; newCapacity - minCapacity = 0, minCapacity &gt; 0</p>
<p>=&gt; return minCapacity</p>
<p>=&gt; elementData.length = 4</p>
</li>
<li><p>size = 4, minCapacity = size + 1 = 5, oldCapacity = elementData.length = 4, newCapacity = 6</p>
<p>=&gt; newCapacity - minCapacity &gt; 0</p>
<p>=&gt; return newCapacity </p>
<p>=&gt; elementData.length = 6</p>
</li>
</ul>
<p>当 elementData.length &lt; 4 时，按 minCapacity 扩容；当element.length &gt;= 4 时，按 newCapacity 扩容。</p>
<h3 id="3）非空数组"><a href="#3）非空数组" class="headerlink" title="3）非空数组"></a>3）非空数组</h3><p>对于非空数组的扩容在上述也提到了，这里就不在赘述了：</p>
<ul>
<li>无参构造的非空数组扩容按 <code>1.5倍</code> 规则</li>
<li>有参构造的非空数组扩容，length &lt; 4 按 <code>+1</code> 扩容，length &gt;= 4 按 <code>1.5倍</code> 扩容</li>
</ul>
<h2 id="3-4-验证"><a href="#3-4-验证" class="headerlink" title="3.4 验证"></a>3.4 验证</h2><p>为了验证上述分析，笔者用反射获取不同情况下添加元素时的elementData长度变化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printInfo</span><span class="params">(ArrayList&lt;Integer&gt; arrayList)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">    <span class="comment">// 反射获取 elementData</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> ArrayList.class.getDeclaredField(<span class="string">&quot;elementData&quot;</span>);</span><br><span class="line">    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加元素与打印</span></span><br><span class="line">    System.out.println(<span class="string">&quot;未添加元素&quot;</span>);</span><br><span class="line">    Object[] objects = (Object[]) field.get(arrayList);</span><br><span class="line">    System.out.println(<span class="string">&quot;初始数组长度：&quot;</span> + objects.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">12</span>; i++) &#123;</span><br><span class="line">        arrayList.add(i);</span><br><span class="line">        System.out.println(<span class="string">&quot;第&quot;</span> + i + <span class="string">&quot;添加元素&quot;</span>);</span><br><span class="line">        objects = (Object[]) field.get(arrayList);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">            objects = (Object[]) field.get(arrayList);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;数组长度：&quot;</span> + objects.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, NoSuchFieldException &#123;</span><br><span class="line">    <span class="comment">// 无参构造实例</span></span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容量参数构造</span></span><br><span class="line">    ArrayList&lt;Integer&gt; arrayList0 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">0</span>); <span class="comment">// 容量为0</span></span><br><span class="line">    ArrayList&lt;Integer&gt; arrayList2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">2</span>); <span class="comment">// 容量为2</span></span><br><span class="line">    ArrayList&lt;Integer&gt; arrayList6 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">6</span>); <span class="comment">// 容量为6</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Collection构造和情况一致，此处省略，可自行设计</span></span><br><span class="line"></span><br><span class="line">    printInfo(list); <span class="comment">// 替换list可以看到不同情况的效果</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果如图，可以看到和上述分析结果一致：</p>
<img src="/2022/05/06/ArrayList%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/%E6%89%93%E5%8D%B0.png" class="" title="文件">

<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p>通过上述的分析可以得到不同情况下的扩容规则（<strong>扩容时机是列表满存</strong>）：</p>
<ol>
<li>使用无参构造 ArrayList() 创建实例，<ul>
<li><strong>首次</strong> 添加元素，扩容为 <code>默认容量 10 </code> </li>
<li>后续满存时按 <code>1.5倍</code> 扩容</li>
</ul>
</li>
<li>使用有参构造 ArrayList(int initialCapacity) 和 ArrayList(Collection&lt;? extends E&gt; c) 创建实例，<ul>
<li>如果添加元素时数组长度（列表容量）小于4，按 <code>+1</code> 扩容</li>
<li>如果添加元素时数组长度（列表容量）大于等于4，按 <code>1.5倍</code> 扩容</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>Collection</category>
        <category>List</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>ArrayList</tag>
        <tag>集合数组扩容机制</tag>
      </tags>
  </entry>
</search>
